<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Jackpot Joker</title>
    <style>
        :root {
            --bg: radial-gradient(circle at top, #1f1147 0%, #090417 55%, #05010d 100%);
            --surface: rgba(20, 12, 48, 0.92);
            --surface-strong: rgba(36, 20, 86, 0.95);
            --primary: #ff7bff;
            --primary-strong: #f64bff;
            --accent: #00e7ff;
            --accent-soft: rgba(0, 231, 255, 0.18);
            --gold: #ffd166;
            --text: #f6ecff;
            --muted: rgba(246, 236, 255, 0.62);
            --shadow: 0 14px 40px rgba(5, 3, 17, 0.55);
            --radius-lg: 24px;
            --radius-md: 18px;
            --radius-sm: 12px;
            --space-xs: 0.375rem;
            --space-sm: 0.75rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --max-width: 680px;
            font-family: "Inter", "Segoe UI", system-ui, sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            min-height: 100%;
            background: var(--bg);
            color: var(--text);
            -webkit-font-smoothing: antialiased;
        }

        body {
            display: flex;
            justify-content: center;
            padding: var(--space-md);
        }

        #app {
            width: min(100%, var(--max-width));
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            padding: var(--space-lg) var(--space-md) calc(var(--space-lg) * 1.4);
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        #app::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255, 123, 255, 0.18), rgba(0, 231, 255, 0.12));
            pointer-events: none;
        }

        header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: var(--space-md);
        }

        header h1 {
            margin: 0;
            font-size: clamp(1.65rem, 5vw, 2.2rem);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-shadow: 0 0 12px rgba(255, 123, 255, 0.6);
        }

        .header-controls {
            display: flex;
            align-items: flex-start;
            gap: var(--space-sm);
        }

        #machine-selector {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: var(--space-xs);
            text-align: right;
        }

        #machine-select {
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text);
            font-weight: 600;
            letter-spacing: 0.05em;
            padding: 0.35rem 0.65rem;
            cursor: pointer;
            min-width: 160px;
        }

        #machine-select:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .icon-button {
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-radius: 999px;
            padding: 0.5rem 0.85rem;
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
            touch-action: manipulation;
        }

        .icon-button:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 3px;
        }

        .icon-button:hover {
            background: rgba(255, 255, 255, 0.16);
        }

        .info-text {
            font-size: 0.85rem;
            color: var(--muted);
            margin: 0;
        }

        #scoreboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--space-sm);
        }

        .score-card {
            background: rgba(255, 255, 255, 0.04);
            border-radius: var(--radius-md);
            padding: var(--space-sm) var(--space-md);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .score-card h2 {
            margin: 0;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--muted);
        }

        .score-card span {
            font-size: clamp(1.35rem, 5vw, 1.75rem);
            font-weight: 700;
            letter-spacing: 0.04em;
        }

        .score-card.boss {
            border-color: rgba(255, 209, 102, 0.55);
            box-shadow: inset 0 0 0 1px rgba(255, 209, 102, 0.2);
        }

        #free-spins-card[hidden] {
            display: none;
        }

        #machine-hint {
            max-width: 220px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-sm);
        }

        .panel-header h2 {
            margin: 0;
            font-size: 1rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        #joker-tray {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            overflow-x: auto;
            padding-bottom: 0.4rem;
            scroll-snap-type: x proximity;
        }

        #joker-tray::-webkit-scrollbar {
            height: 6px;
        }

        #joker-tray::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.25);
            border-radius: 999px;
        }

        .joker-empty {
            font-size: 0.9rem;
            color: var(--muted);
        }

        .chip {
            background: rgba(0, 231, 255, 0.12);
            border: 1px solid rgba(0, 231, 255, 0.24);
            color: var(--accent);
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            font-size: 0.75rem;
            letter-spacing: 0.06em;
        }

        .panel-subhead {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-xs);
        }

        .history-grid {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
        }

        .history-chip {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            padding: 0.25rem 0.6rem;
            font-size: 0.7rem;
            letter-spacing: 0.05em;
            color: var(--muted);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .chip.ready {
            background: rgba(255, 123, 255, 0.18);
            border-color: rgba(255, 123, 255, 0.45);
            color: var(--primary);
            box-shadow: 0 0 14px rgba(255, 123, 255, 0.22);
        }

        #reel-summary {
            display: flex;
            gap: var(--space-sm);
            flex-wrap: wrap;
        }

        #hand-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: var(--space-sm);
        }

        .card {
            position: relative;
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            background: var(--surface-strong);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 14px 20px rgba(3, 1, 12, 0.35);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
            text-align: center;
            min-height: 130px;
        }

        .card::after {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: linear-gradient(140deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0));
            pointer-events: none;
        }

        .card-icon {
            font-size: clamp(1.8rem, 6vw, 2.5rem);
        }

        .card-name {
            font-weight: 700;
            letter-spacing: 0.08em;
            font-size: 0.95rem;
        }

        .card-desc {
            font-size: 0.75rem;
            color: var(--muted);
            line-height: 1.3;
        }

        .hand-card {
            border: none;
            cursor: pointer;
            touch-action: manipulation;
            transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
        }

        .hand-card:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 4px;
        }

        .hand-card.selected {
            transform: translateY(-6px) scale(1.02);
            border: 2px solid var(--primary);
            box-shadow: 0 18px 30px rgba(255, 123, 255, 0.32);
        }

        #card-details {
            font-size: 0.85rem;
            color: var(--muted);
            min-height: 2.2rem;
        }

        #payline-track {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: var(--space-sm);
        }

        .payline-slot {
            position: relative;
            border-radius: var(--radius-sm);
            border: 1px dashed rgba(255, 255, 255, 0.18);
            min-height: 120px;
            display: flex;
            align-items: stretch;
            justify-content: center;
        }

        .payline-slot .card {
            width: 100%;
            min-height: 120px;
        }

        .payline-slot.win {
            border-color: rgba(255, 209, 102, 0.65);
            box-shadow: 0 0 18px rgba(255, 209, 102, 0.32);
        }

        #message-bar {
            min-height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 0.95rem;
            color: var(--text);
            padding: 0.3rem 0.5rem;
        }

        #action-bar {
            position: sticky;
            bottom: 0;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: var(--space-sm);
            padding-top: var(--space-sm);
        }

        .action-button {
            border: none;
            border-radius: var(--radius-sm);
            padding: 0.95rem;
            font-size: 1.05rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: #130722;
            box-shadow: 0 16px 30px rgba(0, 231, 255, 0.25);
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
            touch-action: manipulation;
        }

        .action-button:focus-visible {
            outline: 2px solid var(--gold);
            outline-offset: 3px;
        }

        .action-button:active:not(:disabled) {
            transform: translateY(1px) scale(0.99);
        }

        .action-button:disabled {
            cursor: not-allowed;
            background: rgba(255, 255, 255, 0.12);
            color: rgba(255, 255, 255, 0.4);
            box-shadow: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg) var(--space-md);
            background: rgba(6, 3, 18, 0.72);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .modal[hidden] {
            display: none;
        }

        .modal-card {
            width: min(100%, 520px);
            background: var(--surface-strong);
            border-radius: var(--radius-lg);
            padding: var(--space-lg) var(--space-md);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            max-height: calc(100vh - 3rem);
            overflow-y: auto;
        }

        .modal-card h2 {
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-size: 1.2rem;
        }

        .modal-card p {
            margin: 0;
            line-height: 1.6;
            color: var(--muted);
        }

        .modal-actions {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
            justify-content: flex-end;
        }

        .pill-button {
            border: none;
            border-radius: 999px;
            padding: 0.55rem 1.25rem;
            font-weight: 600;
            letter-spacing: 0.06em;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.12);
            color: var(--text);
            touch-action: manipulation;
        }

        .pill-button.primary {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: #130722;
        }

        .shop-grid {
            display: grid;
            gap: var(--space-sm);
        }

        .shop-item {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: var(--space-sm);
            padding: var(--space-sm);
            border-radius: var(--radius-sm);
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            align-items: center;
        }

        .shop-info {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .shop-info strong {
            font-size: 1rem;
        }

        .shop-status {
            font-size: 0.8rem;
            color: var(--muted);
        }

        .shop-buy {
            margin-top: 0.35rem;
            align-self: flex-start;
            border: none;
            border-radius: 999px;
            padding: 0.45rem 1rem;
            font-weight: 600;
            letter-spacing: 0.06em;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.18);
            color: var(--text);
        }

        .shop-buy:disabled {
            cursor: not-allowed;
            opacity: 0.45;
        }

        #reel-picker {
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: var(--space-sm);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .reel-picker-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .reel-button {
            flex: 1;
            min-width: 120px;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(0, 231, 255, 0.3);
            background: rgba(0, 231, 255, 0.12);
            color: var(--accent);
            padding: 0.6rem 0.9rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            cursor: pointer;
        }

        .reel-button:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .reel-cancel {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.18);
            color: var(--muted);
        }

        .end-summary {
            display: grid;
            gap: var(--space-sm);
            text-align: center;
        }

        .end-summary h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--muted);
            letter-spacing: 0.08em;
        }

        .end-summary span {
            font-size: 1.65rem;
            font-weight: 700;
        }

        body.modal-open {
            overflow: hidden;
        }

        @media (min-width: 768px) {
            #action-bar {
                position: static;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                transition-duration: 0.01ms !important;
                animation-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <div>
                <h1>Jackpot Joker</h1>
                <p class="info-text" id="machine-description">Reach the target score before you run out of draws.</p>
            </div>
            <div class="header-controls">
                <div id="machine-selector">
                    <label class="info-text" for="machine-select">Machine</label>
                    <select id="machine-select" aria-label="Choose slot machine"></select>
                    <p class="info-text" id="machine-hint"></p>
                </div>
                <button class="icon-button" id="help-button" type="button">Rules</button>
            </div>
        </header>

        <section id="scoreboard">
            <div class="score-card">
                <h2>Score</h2>
                <span id="score-value">0 / 100</span>
            </div>
            <div class="score-card">
                <h2>Draws Left</h2>
                <span id="draws-value">8</span>
            </div>
            <div class="score-card" id="blind-card">
                <h2>Blind</h2>
                <span id="blind-value">1</span>
            </div>
            <div class="score-card">
                <h2>Coins</h2>
                <span id="money-value">$0</span>
            </div>
            <div class="score-card" id="free-spins-card" hidden>
                <h2>Free Spins</h2>
                <span id="free-spins-value">0</span>
            </div>
        </section>

        <section class="panel" aria-labelledby="joker-title">
            <div class="panel-header">
                <h2 id="joker-title">Jokers</h2>
                <span class="chip" id="joker-count">0 owned</span>
            </div>
            <div id="joker-tray" aria-live="polite"></div>
            <div class="panel-subhead">
                <span class="info-text">Lifetime joker recruits</span>
            </div>
            <div id="joker-history" class="history-grid" aria-live="polite"></div>
        </section>

        <section class="panel" aria-labelledby="reel-title">
            <div class="panel-header">
                <h2 id="reel-title">Reels</h2>
                <span class="info-text">More symbols mean better odds when drawing.</span>
            </div>
            <div id="reel-summary"></div>
        </section>

        <section class="panel" aria-labelledby="hand-title">
            <div class="panel-header">
                <h2 id="hand-title">Slot Machine</h2>
                <span class="chip" id="selection-status">Ready to spin</span>
            </div>
            <div id="hand-grid" aria-live="polite"></div>
            <div id="card-details"></div>
        </section>

        <section class="panel" aria-labelledby="payline-title">
            <div class="panel-header">
                <h2 id="payline-title">Last Payline</h2>
                <span class="info-text" id="payline-info">Play a hand to see results.</span>
            </div>
            <div id="payline-track"></div>
        </section>

        <div id="message-bar" aria-live="polite"></div>

        <footer id="action-bar">
            <button id="draw-button" class="action-button" type="button">Spin Reels</button>
            <button id="play-button" class="action-button" type="button" hidden>Auto Play</button>
        </footer>
    </div>

    <div class="modal" id="help-modal" hidden>
        <div class="modal-card">
            <h2>How to Play</h2>
            <p>Press <strong>Spin Reels</strong> to let the slot machine handle the hand for you. Behind the scenes it draws five cards and secretly keeps the best combo.</p>
            <p>The selection chip above the slot machine lets you know when the reels are spinning and when you're ready for the next blind.</p>
            <p>After each blind you survive, visit the shop to add new symbols or jokers to your build. Jokers provide powerful bonuses every hand.</p>
            <p>Every third blind is a <strong>Boss Blind</strong> with tougher targets. Beat them all to finish the run. Defeating the final boss unlocks the <strong>Nova Cascade</strong> machine, packed with bonus games and free-spin combos.</p>
            <p>The joker panel tracks every joker you've ever recruited, so chase new synergies and fill out your collection.</p>
            <ul>
                <li>Tap <strong>Spin Reels</strong> to spend a draw and let the machine work.</li>
                <li>The machine secretly evaluates five cards and automatically keeps the best three for you.</li>
                <li>Watch the payline to see what the reels delivered.</li>
                <li>Reach the target score before your draws run out to move on.</li>
            </ul>
            <div class="modal-actions">
                <button class="pill-button primary" id="close-help" type="button">Got it</button>
            </div>
        </div>
    </div>

    <div class="modal" id="shop-modal" hidden aria-live="polite">
        <div class="modal-card">
            <h2>Card Shop</h2>
            <p id="shop-intro">Upgrade your build before the next blind.</p>
            <p><strong>Coins:</strong> <span id="shop-money">$0</span></p>
            <div id="shop-items" class="shop-grid"></div>
            <div id="shop-empty" class="info-text" hidden>Nothing new for sale this time. Enjoy the free rest!</div>
            <div id="reel-picker" hidden>
                <strong id="reel-picker-name">Choose a reel</strong>
                <div class="reel-picker-buttons">
                    <button type="button" class="reel-button" data-reel="0">Reel 1</button>
                    <button type="button" class="reel-button" data-reel="1">Reel 2</button>
                    <button type="button" class="reel-button" data-reel="2">Reel 3</button>
                    <button type="button" class="reel-button reel-cancel" id="reel-cancel">Cancel</button>
                </div>
            </div>
            <div class="modal-actions">
                <button class="pill-button" id="skip-shop" type="button">Skip Shop</button>
                <button class="pill-button primary" id="shop-continue" type="button">Next Blind</button>
            </div>
        </div>
    </div>

    <div class="modal" id="end-modal" hidden>
        <div class="modal-card end-summary">
            <h2 id="end-title">Run Complete</h2>
            <p id="end-message">Well played!</p>
            <div>
                <h3>Highest Blind</h3>
                <span id="end-blind">1</span>
            </div>
            <div>
                <h3>Final Coins</h3>
                <span id="end-coins">$0</span>
            </div>
            <div class="modal-actions" style="justify-content: center;">
                <button class="pill-button primary" id="restart-button" type="button">Play Again</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const elements = {
            scoreValue: document.getElementById('score-value'),
            drawsValue: document.getElementById('draws-value'),
            blindValue: document.getElementById('blind-value'),
            moneyValue: document.getElementById('money-value'),
            freeSpinValue: document.getElementById('free-spins-value'),
            freeSpinCard: document.getElementById('free-spins-card'),
            blindCard: document.getElementById('blind-card'),
            jokerTray: document.getElementById('joker-tray'),
            jokerCount: document.getElementById('joker-count'),
            jokerHistory: document.getElementById('joker-history'),
            reelSummary: document.getElementById('reel-summary'),
            handGrid: document.getElementById('hand-grid'),
            selectionStatus: document.getElementById('selection-status'),
            cardDetails: document.getElementById('card-details'),
            paylineTrack: document.getElementById('payline-track'),
            paylineInfo: document.getElementById('payline-info'),
            messageBar: document.getElementById('message-bar'),
            drawButton: document.getElementById('draw-button'),
            playButton: document.getElementById('play-button'),
            helpButton: document.getElementById('help-button'),
            helpModal: document.getElementById('help-modal'),
            closeHelp: document.getElementById('close-help'),
            machineSelect: document.getElementById('machine-select'),
            machineDescription: document.getElementById('machine-description'),
            machineHint: document.getElementById('machine-hint'),
            shopModal: document.getElementById('shop-modal'),
            shopIntro: document.getElementById('shop-intro'),
            shopMoney: document.getElementById('shop-money'),
            shopItems: document.getElementById('shop-items'),
            shopEmpty: document.getElementById('shop-empty'),
            shopContinue: document.getElementById('shop-continue'),
            skipShop: document.getElementById('skip-shop'),
            reelPicker: document.getElementById('reel-picker'),
            reelPickerName: document.getElementById('reel-picker-name'),
            reelPickerButtons: document.querySelectorAll('.reel-button[data-reel]'),
            reelCancel: document.getElementById('reel-cancel'),
            endModal: document.getElementById('end-modal'),
            endTitle: document.getElementById('end-title'),
            endMessage: document.getElementById('end-message'),
            endBlind: document.getElementById('end-blind'),
            endCoins: document.getElementById('end-coins'),
            restartButton: document.getElementById('restart-button'),
        };

        const storage = (() => {
            try {
                const key = '__jj__';
                window.localStorage.setItem(key, key);
                window.localStorage.removeItem(key);
                return window.localStorage;
            } catch (error) {
                console.warn('Local storage unavailable, persistent features disabled.', error);
                return null;
            }
        })();

        const STORAGE_KEYS = {
            jokerStats: 'jackpotjoker:jokers',
            unlockedMachines: 'jackpotjoker:machines',
            selectedMachine: 'jackpotjoker:selected-machine',
        };

        const cardPool = {
            cherry: { id: 'cherry', name: 'Cherry', type: 'symbol', icon: 'ðŸ’', desc: 'Classic low-tier symbol.', cost: 4, machines: ['classic'] },
            bell: { id: 'bell', name: 'Bell', type: 'symbol', icon: 'ðŸ””', desc: 'Rings in decent payouts.', cost: 6, machines: ['classic'] },
            bar: { id: 'bar', name: 'BAR', type: 'symbol', icon: 'ðŸ…±ï¸', desc: 'Solid mid-tier symbol.', cost: 7, machines: ['classic'] },
            seven: { id: 'seven', name: 'Seven', type: 'symbol', icon: '7ï¸âƒ£', desc: 'Rare and valuable symbol.', cost: 10, machines: ['classic'] },
            diamond: { id: 'diamond', name: 'Diamond', type: 'symbol', icon: 'ðŸ’Ž', desc: 'Doubles a winning score.', cost: 12, machines: ['classic', 'nova'] },
            star: { id: 'star', name: 'Starburst', type: 'symbol', icon: 'ðŸŒ ', desc: 'Reliable glow with steady payouts.', cost: 6, machines: ['nova'] },
            comet: { id: 'comet', name: 'Comet Trail', type: 'symbol', icon: 'â˜„ï¸', desc: 'Streaks of score when grouped.', cost: 7, machines: ['nova'] },
            nova: { id: 'nova', name: 'Nova Core', type: 'symbol', icon: 'ðŸ’¥', desc: 'Explosive jackpot potential.', cost: 12, machines: ['nova'] },
            free_spin: { id: 'free_spin', name: 'Free Spin', type: 'symbol', icon: 'ðŸŒ€', desc: 'Pair these to gain free spins.', cost: 9, machines: ['nova'] },
            bonus_chip: { id: 'bonus_chip', name: 'Bonus Chip', type: 'symbol', icon: 'ðŸŽ°', desc: 'Three trigger a bonus game.', cost: 11, machines: ['nova'] },
            jester: { id: 'jester', name: 'Jester', type: 'joker', icon: 'ðŸ¤¹', desc: 'Winning hands earn +$2.', cost: 9, effect: (payout) => {
                if (payout.score > 0) {
                    payout.money += 2;
                    return 'Jester tips +$2';
                }
            } },
            midas: { id: 'midas', name: 'Midas Touch', type: 'joker', icon: 'ðŸ‘‘', desc: 'Each BAR in a hand grants +10 score.', cost: 12, effect: (payout, cards) => {
                const bonus = cards.filter(card => card.id === 'bar').length * 10;
                if (bonus > 0) {
                    payout.score += bonus;
                    return `Midas bonus +${bonus} score`;
                }
            } },
            clover: { id: 'clover', name: 'Lucky Clover', type: 'joker', icon: 'ðŸ€', desc: '20% chance to gain +$1 on a miss.', cost: 8, effect: (payout) => {
                if (payout.score === 0 && Math.random() < 0.2) {
                    payout.money += 1;
                    return 'Lucky Clover +$1';
                }
            } },
            greased_lever: { id: 'greased_lever', name: 'Greased Lever', type: 'joker', icon: 'ðŸ› ï¸', desc: 'Gain +2 draws every blind.', cost: 11, spinBonus: 2 },
            silver_star: { id: 'silver_star', name: 'Silver Star', type: 'joker', icon: 'â­', desc: '+15 score for winning with Bells.', cost: 11, effect: (payout, cards) => {
                if (payout.score > 0 && cards.some(card => card.id === 'bell')) {
                    payout.score += 15;
                    return 'Silver Star +15 score';
                }
            } },
            fortune_cat: { id: 'fortune_cat', name: 'Fortune Cat', type: 'joker', icon: 'ðŸ±', desc: 'Cherry wins give +5 score & +$1.', cost: 10, effect: (payout, cards) => {
                if (payout.score > 0 && cards.some(card => card.id === 'cherry')) {
                    payout.score += 5;
                    payout.money += 1;
                    return 'Fortune Cat bats in +5 score & +$1';
                }
            } },
            ringmaster: { id: 'ringmaster', name: 'Ringmaster', type: 'joker', icon: 'ðŸŽ©', desc: 'Mixed hands of 3 symbols earn +18 score.', cost: 13, effect: (payout, cards) => {
                const ids = new Set(cards.map(card => card.id));
                if (ids.size === 3) {
                    payout.score += 18;
                    return 'Ringmaster rewards the variety (+18)';
                }
            } },
            vault_key: { id: 'vault_key', name: 'Vault Key', type: 'joker', icon: 'ðŸ—ï¸', desc: 'Winning hands earn +$1 and +1 draw.', cost: 12, effect: (payout) => {
                if (payout.score > 0) {
                    payout.money += 1;
                    payout.extraDraws = (payout.extraDraws || 0) + 1;
                    return 'Vault Key grants +$1 & a bonus draw';
                }
            } },
        };

        const machineConfigs = {
            classic: {
                id: 'classic',
                name: 'Classic Jackpot',
                description: 'Balanced reels and friendlier blinds for a faster climb.',
                selectionLimit: 3,
                handSize: 5,
                startingMoney: 8,
                supportsFreeSpins: false,
                blinds: [
                    { score: 60, draws: 9, type: 'standard', title: 'Lobby Warm-up' },
                    { score: 150, draws: 9, type: 'standard', title: 'Main Floor' },
                    { score: 260, draws: 9, type: 'boss', title: 'Pit Boss Pike' },
                    { score: 380, draws: 8, type: 'standard', title: 'Vault Stacks' },
                    { score: 540, draws: 8, type: 'standard', title: 'Glitter Row' },
                    { score: 720, draws: 8, type: 'boss', title: 'High Roller Duel' },
                    { score: 900, draws: 7, type: 'standard', title: 'Showroom Finale' },
                    { score: 1100, draws: 7, type: 'standard', title: 'Jackpot Parade' },
                    { score: 1400, draws: 7, type: 'boss', title: 'Vault Guardian' },
                ],
                payoutTable: {
                    cherry: [{ score: 10, money: 1 }, { score: 25, money: 2 }, { score: 55, money: 4 }],
                    bell: [{ score: 0, money: 0 }, { score: 40, money: 3 }, { score: 70, money: 6 }],
                    bar: [{ score: 0, money: 0 }, { score: 55, money: 5 }, { score: 100, money: 10 }],
                    seven: [{ score: 0, money: 0 }, { score: 0, money: 0 }, { score: 150, money: 20 }],
                    diamond: [{ score: 0, money: 0 }, { score: 0, money: 0 }, { score: 120, money: 15 }],
                },
                createInitialReels: () => Array.from({ length: 3 }, () => ['cherry', 'cherry', 'cherry', 'bar', 'bar', 'bell', 'bell', 'seven', 'diamond']),
            },
            nova: {
                id: 'nova',
                name: 'Nova Cascade',
                description: 'Bonus games and free spins for daring cosmic combos.',
                selectionLimit: 3,
                handSize: 5,
                startingMoney: 10,
                supportsFreeSpins: true,
                blinds: [
                    { score: 80, draws: 9, type: 'standard', title: 'Nebula Gate' },
                    { score: 200, draws: 9, type: 'standard', title: 'Meteor Drift' },
                    { score: 360, draws: 9, type: 'boss', title: 'Singularity Showdown' },
                    { score: 540, draws: 8, type: 'standard', title: 'Quantum Carousel' },
                    { score: 760, draws: 8, type: 'standard', title: 'Aurora Overdrive' },
                    { score: 1020, draws: 8, type: 'boss', title: 'Galactic Dealer' },
                    { score: 1280, draws: 7, type: 'standard', title: 'Supernova Spin' },
                    { score: 1580, draws: 7, type: 'standard', title: 'Event Horizon' },
                    { score: 1900, draws: 7, type: 'boss', title: 'Cosmic High Roller' },
                ],
                payoutTable: {
                    star: [{ score: 12, money: 1 }, { score: 32, money: 3 }, { score: 80, money: 6 }],
                    comet: [{ score: 0, money: 0 }, { score: 45, money: 3 }, { score: 95, money: 7 }],
                    nova: [{ score: 0, money: 0 }, { score: 70, money: 4 }, { score: 180, money: 14 }],
                    free_spin: [{ score: 0, money: 0 }, { score: 0, money: 0 }, { score: 30, money: 4 }],
                    bonus_chip: [{ score: 0, money: 0 }, { score: 35, money: 4 }, { score: 90, money: 8 }],
                    diamond: [{ score: 0, money: 0 }, { score: 0, money: 0 }, { score: 120, money: 15 }],
                },
                createInitialReels: () => Array.from({ length: 3 }, () => ['star', 'star', 'comet', 'comet', 'nova', 'free_spin', 'bonus_chip', 'diamond', 'diamond']),
                applyRewards: ({ payout, cards, state }) => {
                    const notes = [];
                    const counts = cards.reduce((map, card, index) => {
                        map[card.id] = map[card.id] || { count: 0, indices: [] };
                        map[card.id].count += 1;
                        map[card.id].indices.push(index);
                        return map;
                    }, {});

                    if (counts.free_spin?.count >= 2) {
                        const extra = counts.free_spin.count >= 3 ? 3 : 2;
                        state.freeSpins += extra;
                        state.drawsLeft += extra;
                        payout.winningIndices = Array.from(new Set([...(payout.winningIndices || []), ...counts.free_spin.indices]));
                        notes.push(`Free Spins +${extra}`);
                    }

                    if (counts.bonus_chip?.count >= 3) {
                        const bonusScore = 50 + Math.floor(Math.random() * 41);
                        const bonusMoney = 5 + Math.floor(Math.random() * 4);
                        payout.score += bonusScore;
                        payout.money += bonusMoney;
                        payout.winningIndices = Array.from(new Set([...(payout.winningIndices || []), ...counts.bonus_chip.indices]));
                        notes.push(`Bonus Game +${bonusScore} score`);
                        notes.push(`Bonus Game +$${bonusMoney}`);
                    }

                    return notes;
                },
            },
        };

        const persistent = {
            jokerStats: loadJokerStats(),
            unlockedMachines: loadUnlockedMachines(),
        };

        const state = {
            machine: getInitialMachine(),
            blindIndex: 0,
            score: 0,
            money: 0,
            drawsLeft: 0,
            hand: [],
            selection: [],
            jokers: [],
            reels: [],
            lastPayline: [],
            lastPayout: null,
            canDraw: true,
            canPlay: false,
            message: '',
            gameOver: false,
            shopOpen: false,
            shopChoices: [],
            pendingSymbol: null,
            freeSpins: 0,
            autoSelecting: false,
        };

        let autoPlayTimer = null;

        function loadJSON(key, fallback) {
            if (!storage) return fallback;
            try {
                const stored = storage.getItem(key);
                return stored ? JSON.parse(stored) : fallback;
            } catch (error) {
                console.warn('Failed to read storage key', key, error);
                return fallback;
            }
        }

        function saveJSON(key, value) {
            if (!storage) return;
            try {
                storage.setItem(key, JSON.stringify(value));
            } catch (error) {
                console.warn('Failed to save storage key', key, error);
            }
        }

        function loadJokerStats() {
            const data = loadJSON(STORAGE_KEYS.jokerStats, {});
            return data && typeof data === 'object' ? data : {};
        }

        function saveJokerStats(stats) {
            saveJSON(STORAGE_KEYS.jokerStats, stats);
        }

        function loadUnlockedMachines() {
            const list = loadJSON(STORAGE_KEYS.unlockedMachines, ['classic']);
            const unique = Array.from(new Set(['classic', ...(Array.isArray(list) ? list : [])]));
            return unique;
        }

        function saveUnlockedMachines(list) {
            saveJSON(STORAGE_KEYS.unlockedMachines, list);
        }

        function loadSelectedMachine() {
            const stored = loadJSON(STORAGE_KEYS.selectedMachine, 'classic');
            return typeof stored === 'string' ? stored : 'classic';
        }

        function saveSelectedMachine(machineId) {
            saveJSON(STORAGE_KEYS.selectedMachine, machineId);
        }

        function isMachineUnlocked(machineId) {
            return persistent.unlockedMachines.includes(machineId);
        }

        function unlockMachine(machineId) {
            if (isMachineUnlocked(machineId)) return false;
            persistent.unlockedMachines.push(machineId);
            saveUnlockedMachines(persistent.unlockedMachines);
            return true;
        }

        function getInitialMachine() {
            const preferred = loadSelectedMachine();
            return isMachineUnlocked(preferred) ? preferred : 'classic';
        }

        function getCurrentMachineConfig() {
            return machineConfigs[state.machine] || machineConfigs.classic;
        }

        function getBlinds() {
            return getCurrentMachineConfig().blinds;
        }

        function getHandSize() {
            return getCurrentMachineConfig().handSize;
        }

        function getSelectionLimit() {
            return getCurrentMachineConfig().selectionLimit;
        }

        function getPayoutTable() {
            return getCurrentMachineConfig().payoutTable;
        }

        function machineSupportsFreeSpins() {
            return Boolean(getCurrentMachineConfig().supportsFreeSpins);
        }

        function buildInitialReels() {
            const builder = getCurrentMachineConfig().createInitialReels;
            if (typeof builder === 'function') {
                return builder().map(reel => [...reel]);
            }
            return [[], [], []];
        }

        function isCardAvailableForMachine(card, machineId = state.machine) {
            return !card.machines || card.machines.includes(machineId);
        }

        function getMachineSymbolIds(machineId = state.machine) {
            return Object.values(cardPool)
                .filter(card => card.type === 'symbol' && isCardAvailableForMachine(card, machineId))
                .map(card => card.id);
        }

        function getMachineJokerIds(machineId = state.machine) {
            return Object.values(cardPool)
                .filter(card => card.type === 'joker' && isCardAvailableForMachine(card, machineId))
                .map(card => card.id);
        }

        function addPayoutNotes(payout, extraNotes) {
            if (!extraNotes || extraNotes.length === 0) {
                return payout;
            }
            const base = payout.baseMessage || payout.displayMessage.split(' â€” ')[0];
            const combined = [...(payout.notes || []), ...extraNotes];
            payout.baseMessage = base;
            payout.notes = combined;
            payout.displayMessage = `${base} â€” ${combined.join(' Â· ')}`;
            return payout;
        }

        function recordJokerUse(jokerId) {
            if (!jokerId) return;
            persistent.jokerStats[jokerId] = (persistent.jokerStats[jokerId] || 0) + 1;
            saveJokerStats(persistent.jokerStats);
        }

        function updateMachineUI() {
            if (!elements.machineSelect) return;
            elements.machineSelect.innerHTML = '';
            Object.values(machineConfigs).forEach(config => {
                const option = document.createElement('option');
                const unlocked = isMachineUnlocked(config.id);
                option.value = config.id;
                option.textContent = unlocked ? config.name : `${config.name} (locked)`;
                option.disabled = !unlocked;
                elements.machineSelect.appendChild(option);
            });
            elements.machineSelect.value = state.machine;
            if (elements.machineHint) {
                elements.machineHint.textContent = isMachineUnlocked('nova')
                    ? 'Nova Cascade is unlocked â€” enjoy bonus games and free spins!'
                    : 'Defeat the final boss to unlock Nova Cascade.';
            }
            if (elements.machineDescription) {
                elements.machineDescription.textContent = getCurrentMachineConfig().description;
            }
        }

        function startGame() {
            const config = getCurrentMachineConfig();
            saveSelectedMachine(state.machine);
            cancelAutoPlay();
            state.blindIndex = 0;
            state.money = config.startingMoney;
            state.jokers = [];
            state.reels = buildInitialReels();
            state.lastPayline = [];
            state.lastPayout = null;
            state.gameOver = false;
            state.freeSpins = 0;
            state.hand = [];
            state.selection = [];
            state.autoSelecting = false;
            updateMachineUI();
            startBlind();
        }

        function startBlind() {
            const blind = getBlinds()[state.blindIndex];
            state.score = 0;
            state.drawsLeft = blind.draws + getTotalSpinBonus();
            state.hand = [];
            state.selection = [];
            state.canDraw = true;
            state.canPlay = false;
            state.lastPayline = [];
            state.lastPayout = null;
            state.freeSpins = 0;
            state.autoSelecting = false;
            cancelAutoPlay();
            const prefix = blind.type === 'boss' ? 'Boss Blind' : `Blind ${state.blindIndex + 1}`;
            const title = blind.title ? `${prefix}: ${blind.title}` : `${prefix}`;
            state.message = `${title}. Score ${blind.score} before you run out of draws.`;
            updateUI();
        }

        function getTotalSpinBonus() {
            return state.jokers.reduce((bonus, jokerId) => {
                const joker = cardPool[jokerId];
                return bonus + (joker.spinBonus || 0);
            }, 0);
        }

        function cancelAutoPlay() {
            if (autoPlayTimer !== null) {
                clearTimeout(autoPlayTimer);
                autoPlayTimer = null;
            }
        }

        function scheduleAutoPlay() {
            cancelAutoPlay();
            autoPlayTimer = window.setTimeout(() => {
                autoPlayTimer = null;
                autoPlayBestHand();
            }, 550);
        }

        function drawHand() {
            if (!state.canDraw || state.gameOver || state.drawsLeft <= 0) return;
            const deck = shuffle([...state.reels[0], ...state.reels[1], ...state.reels[2]]);
            state.hand = [];
            const handSize = getHandSize();
            for (let i = 0; i < handSize && deck.length; i++) {
                state.hand.push(deck.pop());
            }
            state.selection = [];
            state.canDraw = false;
            state.canPlay = true;
            state.drawsLeft -= 1;
            if (state.freeSpins > 0) {
                state.freeSpins -= 1;
            }
            state.autoSelecting = true;
            state.message = 'Spinning the reels...';
            updateUI();
            scheduleAutoPlay();
        }

        function toggleSelection(index) {
            if (!state.canPlay || state.gameOver) return;
            const currentIndex = state.selection.indexOf(index);
            if (currentIndex >= 0) {
                state.selection.splice(currentIndex, 1);
            } else if (state.selection.length < getSelectionLimit()) {
                state.selection.push(index);
            }
            updateSelectionStatus();
            updateHandSelectionStyles();
            updateSelectionDetails();
            updateUIControls();
        }

        function autoPlayBestHand() {
            if (!state.canPlay || state.gameOver) {
                state.autoSelecting = false;
                updateSelectionStatus();
                updateUIControls();
                return;
            }

            const limit = getSelectionLimit();
            if (state.hand.length < limit) {
                state.autoSelecting = false;
                updateSelectionStatus();
                updateUIControls();
                return;
            }

            const best = findBestAutoSelection(limit);
            if (best && Array.isArray(best.indices) && best.indices.length === limit) {
                state.selection = best.indices.slice();
            } else {
                state.selection = Array.from({ length: limit }, (_, index) => index).slice(0, limit);
            }

            updateSelectionStatus();
            updateUIControls();
            playHand();
        }

        function findBestAutoSelection(limit) {
            const indices = Array.from({ length: state.hand.length }, (_, index) => index);
            let best = null;
            const combo = [];

            const evaluate = () => {
                const cards = combo.map(idx => cardPool[state.hand[idx]]).filter(Boolean);
                if (cards.length !== limit) {
                    return;
                }
                const payout = calculatePayout(cards) || { score: 0, money: 0 };
                const score = Number.isFinite(payout.score) ? payout.score : 0;
                const money = Number.isFinite(payout.money) ? payout.money : 0;
                const diamondCount = cards.filter(card => card.id === 'diamond').length;
                const uniqueSymbols = new Set(cards.map(card => card.id)).size;
                const freeSpinCount = cards.filter(card => card.id === 'free_spin').length;
                const bonusChipCount = cards.filter(card => card.id === 'bonus_chip').length;
                const potentialExtras = (freeSpinCount >= 2 ? freeSpinCount : 0) + (bonusChipCount >= 3 ? bonusChipCount : 0);
                const candidate = {
                    indices: combo.slice(),
                    score,
                    money,
                    diamondCount,
                    uniqueSymbols,
                    potentialExtras,
                };
                if (!best || isBetterAutoSelection(candidate, best)) {
                    best = candidate;
                }
            };

            const choose = (start) => {
                if (combo.length === limit) {
                    evaluate();
                    return;
                }
                for (let i = start; i < indices.length; i++) {
                    combo.push(indices[i]);
                    choose(i + 1);
                    combo.pop();
                }
            };

            choose(0);
            return best;
        }

        function isBetterAutoSelection(candidate, current) {
            if (!current) return true;
            if (candidate.score !== current.score) return candidate.score > current.score;
            if (candidate.money !== current.money) return candidate.money > current.money;
            if (candidate.potentialExtras !== current.potentialExtras) return candidate.potentialExtras > current.potentialExtras;
            if (candidate.diamondCount !== current.diamondCount) return candidate.diamondCount > current.diamondCount;
            if (candidate.uniqueSymbols !== current.uniqueSymbols) return candidate.uniqueSymbols < current.uniqueSymbols;
            const candidateKey = candidate.indices.join(',');
            const currentKey = current.indices.join(',');
            return candidateKey < currentKey;
        }

        function playHand() {
            if (!state.canPlay || state.selection.length !== getSelectionLimit() || state.gameOver) return;
            cancelAutoPlay();
            state.autoSelecting = false;
            const orderedSelection = [...state.selection].sort((a, b) => a - b);
            const cards = orderedSelection.map(idx => cardPool[state.hand[idx]]);
            let payout = calculatePayout(cards);
            payout = applyJokerEffects(payout, cards);
            payout = applyMachineRewards(payout, cards);

            state.score += payout.score;
            state.money += payout.money;
            if (payout.extraDraws) {
                state.drawsLeft += payout.extraDraws;
            }
            state.lastPayline = cards;
            state.lastPayout = payout;
            state.message = payout.displayMessage;

            state.hand = [];
            state.selection = [];
            state.canPlay = false;
            state.canDraw = state.drawsLeft > 0;

            updateUI();
            checkBlindState();
        }

        function calculatePayout(cards) {
            const payoutTable = getPayoutTable();
            const counts = {};
            let hasDiamond = false;
            cards.forEach((card, index) => {
                counts[card.id] = (counts[card.id] || { count: 0, indices: [] });
                counts[card.id].count += 1;
                counts[card.id].indices.push(index);
                if (card.id === 'diamond') hasDiamond = true;
            });

            let best = { score: 0, money: 0, indices: [], symbol: null, notes: [] };
            Object.entries(counts).forEach(([id, data]) => {
                const table = payoutTable[id];
                if (!table) return;
                const tier = table[data.count - 1];
                if (!tier) return;
                const score = tier.score;
                const money = tier.money;
                if (score > best.score || (score === best.score && money > best.money)) {
                    best = { score, money, indices: data.indices, symbol: id, notes: [] };
                }
            });

            if (best.score > 0 && hasDiamond && best.symbol !== 'diamond') {
                best.score *= 2;
                best.notes.push('Diamond doubles the score');
                cards.forEach((card, index) => {
                    if (card.id === 'diamond') {
                        best.indices.push(index);
                    }
                });
            }

            const message = best.score > 0
                ? `Win! +${best.score} score${best.money > 0 ? ` & +$${best.money}` : ''}`
                : (best.money > 0 ? `You found $${best.money}` : 'No win this time.');

            return {
                score: best.score,
                money: best.money,
                winningIndices: [...new Set(best.indices)],
                notes: best.notes,
                displayMessage: message,
                baseMessage: message,
            };
        }

        function applyJokerEffects(payout, cards) {
            const notes = [];
            state.jokers.forEach(jokerId => {
                const joker = cardPool[jokerId];
                if (typeof joker?.effect === 'function') {
                    const note = joker.effect(payout, cards);
                    if (note) {
                        notes.push(note);
                    }
                }
            });
            return addPayoutNotes(payout, notes);
        }

        function applyMachineRewards(payout, cards) {
            const config = getCurrentMachineConfig();
            if (typeof config.applyRewards !== 'function') {
                return payout;
            }
            const result = config.applyRewards({ payout, cards, state });
            const notes = Array.isArray(result) ? result : (result ? [result] : []);
            return addPayoutNotes(payout, notes);
        }

        function checkBlindState() {
            const blinds = getBlinds();
            const blind = blinds[state.blindIndex];
            if (state.score >= blind.score) {
                if (state.blindIndex === blinds.length - 1) {
                    endRun(true);
                } else {
                    openShop();
                }
                return;
            }

            if (state.drawsLeft <= 0 && !state.canDraw && !state.canPlay) {
                endRun(false);
            }
        }

        function openShop() {
            state.shopOpen = true;
            state.canDraw = false;
            state.canPlay = false;
            state.shopChoices = generateShopChoices();
            state.pendingSymbol = null;
            const blind = getBlinds()[state.blindIndex];
            elements.shopIntro.textContent = blind?.type === 'boss'
                ? 'You toppled a boss! Reinforce your build before the next challenge.'
                : 'Spend your coins to power up for the next blind.';
            updateShopUI();
            openModal(elements.shopModal);
        }

        function generateShopChoices() {
            const choices = [];
            const availableSymbols = shuffle(getMachineSymbolIds().slice());
            const availableJokers = shuffle(getMachineJokerIds().filter(id => !state.jokers.includes(id)));

            while (choices.length < 4 && (availableSymbols.length || availableJokers.length)) {
                if (choices.length < 2 && availableSymbols.length) {
                    choices.push({ id: availableSymbols.shift(), state: 'available' });
                } else if (availableJokers.length) {
                    choices.push({ id: availableJokers.shift(), state: 'available' });
                } else if (availableSymbols.length) {
                    choices.push({ id: availableSymbols.shift(), state: 'available' });
                } else {
                    break;
                }
            }
            return choices;
        }

        function attemptPurchase(choice) {
            const card = cardPool[choice.id];
            if (!card || state.pendingSymbol || choice.state !== 'available' || !isCardAvailableForMachine(card)) return;
            if (state.money < card.cost) {
                elements.shopIntro.textContent = "You can't afford that yet.";
                return;
            }
            state.money -= card.cost;
            if (card.type === 'joker') {
                state.jokers.push(card.id);
                choice.state = 'owned';
                elements.shopIntro.textContent = `${card.name} joins your crew!`;
                recordJokerUse(card.id);
                renderJokerHistory();
            } else {
                state.pendingSymbol = { choice, cardId: card.id };
                choice.state = 'pending';
                elements.reelPickerName.textContent = `Choose a reel for ${card.name}`;
                elements.reelPicker.hidden = false;
            }
            updateShopUI();
            updateUI();
        }

        function assignSymbolToReel(reelIndex) {
            if (!state.pendingSymbol) return;
            const { cardId, choice } = state.pendingSymbol;
            if (!isCardAvailableForMachine(cardPool[cardId])) return;
            state.reels[reelIndex].push(cardId);
            choice.state = 'placed';
            choice.reel = reelIndex + 1;
            elements.shopIntro.textContent = `${cardPool[cardId].name} added to Reel ${reelIndex + 1}!`;
            state.pendingSymbol = null;
            elements.reelPicker.hidden = true;
            updateShopUI();
            updateUI();
        }

        function cancelPendingSymbol() {
            if (!state.pendingSymbol) return;
            const { cardId, choice } = state.pendingSymbol;
            state.money += cardPool[cardId].cost;
            choice.state = 'available';
            state.pendingSymbol = null;
            elements.reelPicker.hidden = true;
            elements.shopIntro.textContent = 'Purchase cancelled.';
            updateShopUI();
            updateUI();
        }

        function finishShop() {
            if (state.pendingSymbol) return;
            closeModal(elements.shopModal);
            state.shopOpen = false;
            state.blindIndex += 1;
            const totalBlinds = getBlinds().length;
            if (state.blindIndex >= totalBlinds) {
                endRun(true);
            } else {
                startBlind();
            }
        }

        function skipShop() {
            if (state.pendingSymbol) return;
            elements.shopIntro.textContent = 'Skipping the shop... good luck out there!';
            finishShop();
        }

        function endRun(victory) {
            cancelAutoPlay();
            state.autoSelecting = false;
            state.gameOver = true;
            state.canDraw = false;
            state.canPlay = false;
            state.freeSpins = 0;
            closeModal(elements.shopModal);
            const config = getCurrentMachineConfig();
            const totalBlinds = getBlinds().length;
            elements.endTitle.textContent = victory ? 'Jackpot!' : 'Run Over';
            if (victory) {
                let message = `You conquered every blind on ${config.name}.`;
                if (state.machine === 'classic') {
                    const unlockedNow = unlockMachine('nova');
                    if (unlockedNow) {
                        message += ' Nova Cascade is now unlocked!';
                        updateMachineUI();
                    }
                }
                elements.endMessage.textContent = message;
            } else {
                elements.endMessage.textContent = 'You ran out of draws before meeting the blind.';
            }
            elements.endBlind.textContent = victory ? totalBlinds : Math.min(state.blindIndex + 1, totalBlinds);
            elements.endCoins.textContent = `$${state.money}`;
            openModal(elements.endModal);
        }

        function restartGame() {
            closeModal(elements.endModal);
            state.shopOpen = false;
            startGame();
        }

        function getSelectionStatusText() {
            if (state.gameOver) {
                return 'Run complete';
            }
            if (state.shopOpen) {
                return 'Shop open â€” finish up to keep spinning';
            }
            if (state.autoSelecting) {
                return 'Spinning for the best combo...';
            }
            if (state.drawsLeft === 0 && !state.canDraw && !state.canPlay) {
                return 'No spins left';
            }
            if (state.canDraw) {
                return 'Ready to spin';
            }
            if (!state.canDraw && state.canPlay) {
                return 'Optimizing your spin...';
            }
            return 'Reels cooling down';
        }

        function updateSelectionStatus() {
            elements.selectionStatus.textContent = getSelectionStatusText();
            const ready = !state.gameOver && !state.autoSelecting && state.canDraw;
            elements.selectionStatus.classList.toggle('ready', ready);
        }

        function updateHandSelectionStyles() {
            const buttons = elements.handGrid.querySelectorAll('.hand-card');
            buttons.forEach(button => {
                const index = Number(button.dataset.index);
                if (state.selection.includes(index)) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });
        }

        function updateUI() {
            const config = getCurrentMachineConfig();
            const blinds = getBlinds();
            const blind = blinds[state.blindIndex] || blinds[blinds.length - 1];
            const totalBlinds = blinds.length;
            elements.scoreValue.textContent = blind ? `${state.score} / ${blind.score}` : `${state.score}`;
            elements.drawsValue.textContent = state.drawsLeft;
            const blindLabelParts = [];
            const currentBlindNumber = Math.min(state.blindIndex + 1, totalBlinds);
            if (totalBlinds > 0) {
                blindLabelParts.push(`${currentBlindNumber} / ${totalBlinds}`);
            } else {
                blindLabelParts.push(`${currentBlindNumber}`);
            }
            if (blind?.type === 'boss') {
                blindLabelParts.push('Boss');
            }
            elements.blindValue.textContent = blindLabelParts.join(' â€¢ ');
            elements.blindCard.classList.toggle('boss', blind?.type === 'boss');
            elements.moneyValue.textContent = `$${state.money}`;
            if (elements.machineDescription) {
                elements.machineDescription.textContent = config.description;
            }
            if (elements.machineSelect && elements.machineSelect.value !== state.machine) {
                elements.machineSelect.value = state.machine;
            }
            const showFreeSpins = machineSupportsFreeSpins() || state.freeSpins > 0;
            if (elements.freeSpinCard) {
                elements.freeSpinCard.hidden = !showFreeSpins;
            }
            if (elements.freeSpinValue) {
                elements.freeSpinValue.textContent = state.freeSpins;
            }
            updateSelectionStatus();

            renderHand();
            renderJokers();
            renderJokerHistory();
            renderReels();
            renderPayline();
            updateMessage();
            updateUIControls();

            if (state.shopOpen) {
                updateShopUI();
            }
        }

        function renderHand() {
            elements.handGrid.innerHTML = '';
            const info = document.createElement('p');
            info.className = 'info-text';
            if (state.autoSelecting) {
                info.textContent = 'The reels are spinning and picking the best combo for you...';
            } else if (state.shopOpen) {
                info.textContent = 'Finish your shopping to prepare the next spin.';
            } else if (state.drawsLeft === 0 && !state.canDraw && !state.canPlay) {
                info.textContent = 'No spins left for this blind.';
            } else if (state.canDraw) {
                info.textContent = 'Tap Spin Reels to let the machine work its magic.';
            } else {
                info.textContent = 'The slot machine is getting ready for the next spin.';
            }
            elements.handGrid.appendChild(info);
            elements.cardDetails.textContent = 'The machine automatically plays the strongest set of cards each spin.';
        }

        function showCardDetails(card) {
            if (!card) {
                elements.cardDetails.textContent = 'The machine automatically plays the strongest set of cards each spin.';
                return;
            }
            elements.cardDetails.textContent = `${card.name}: ${card.desc}`;
        }

        function updateSelectionDetails() {
            showCardDetails(null);
        }

        function renderJokers() {
            elements.jokerTray.innerHTML = '';
            if (state.jokers.length === 0) {
                const span = document.createElement('span');
                span.className = 'joker-empty';
                span.textContent = 'No jokers yet. Visit the shop after a win to recruit one.';
                elements.jokerTray.appendChild(span);
            } else {
                state.jokers.forEach(jokerId => {
                    const joker = cardPool[jokerId];
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.style.minHeight = '120px';
                    card.innerHTML = `<span class="card-icon">${joker.icon}</span><span class="card-name">${joker.name}</span><span class="card-desc">${joker.desc}</span>`;
                    elements.jokerTray.appendChild(card);
                });
            }
            const label = state.jokers.length === 1 ? 'joker' : 'jokers';
            elements.jokerCount.textContent = `${state.jokers.length} ${label}`;
        }

        function renderJokerHistory() {
            if (!elements.jokerHistory) return;
            elements.jokerHistory.innerHTML = '';
            const entries = Object.entries(persistent.jokerStats)
                .filter(([id, count]) => cardPool[id]?.type === 'joker' && count > 0)
                .sort((a, b) => {
                    const nameA = cardPool[a[0]]?.name || '';
                    const nameB = cardPool[b[0]]?.name || '';
                    return nameA.localeCompare(nameB);
                });

            if (entries.length === 0) {
                const span = document.createElement('span');
                span.className = 'info-text';
                span.textContent = 'Recruit jokers to build your collection.';
                elements.jokerHistory.appendChild(span);
                return;
            }

            entries.forEach(([jokerId, count]) => {
                const joker = cardPool[jokerId];
                if (!joker) return;
                const chip = document.createElement('span');
                chip.className = 'history-chip';
                chip.textContent = `${joker.name} Ã—${count}`;
                elements.jokerHistory.appendChild(chip);
            });
        }

        function renderReels() {
            elements.reelSummary.innerHTML = '';
            state.reels.forEach((reel, index) => {
                const reelChip = document.createElement('span');
                reelChip.className = 'chip';
                reelChip.textContent = `Reel ${index + 1}: ${reel.length} cards`;
                elements.reelSummary.appendChild(reelChip);
            });
        }

        function renderPayline() {
            elements.paylineTrack.innerHTML = '';
            if (state.lastPayline.length === 0) {
                for (let i = 0; i < 3; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'payline-slot';
                    elements.paylineTrack.appendChild(slot);
                }
                elements.paylineInfo.textContent = 'Play a hand to see results.';
                return;
            }
            state.lastPayline.forEach((card, index) => {
                const slot = document.createElement('div');
                slot.className = 'payline-slot';
                if (state.lastPayout?.winningIndices?.includes(index)) {
                    slot.classList.add('win');
                }
                const cardEl = document.createElement('div');
                cardEl.className = 'card';
                cardEl.innerHTML = `<span class="card-icon">${card.icon}</span><span class="card-name">${card.name}</span>`;
                slot.appendChild(cardEl);
                elements.paylineTrack.appendChild(slot);
            });
            elements.paylineInfo.textContent = state.lastPayout?.displayMessage || '';
        }

        function updateMessage() {
            elements.messageBar.textContent = state.message || '';
        }

        function updateUIControls() {
            elements.drawButton.disabled = !state.canDraw || state.gameOver;
            if (elements.playButton) {
                elements.playButton.disabled = true;
                elements.playButton.hidden = true;
            }
        }

        function updateShopUI() {
            elements.shopMoney.textContent = `$${state.money}`;
            elements.shopItems.innerHTML = '';

            if (state.shopChoices.length === 0) {
                elements.shopEmpty.hidden = false;
            } else {
                elements.shopEmpty.hidden = true;
                state.shopChoices.forEach(choice => {
                    const card = cardPool[choice.id];
                    const row = document.createElement('div');
                    row.className = 'shop-item';

                    const preview = document.createElement('div');
                    preview.className = 'card';
                    preview.style.minHeight = '110px';
                    preview.innerHTML = `<span class="card-icon">${card.icon}</span>`;

                    const info = document.createElement('div');
                    info.className = 'shop-info';
                    info.innerHTML = `<strong>${card.name}</strong><span class="shop-status">${card.desc}</span>`;

                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'shop-buy';

                    if (choice.state === 'available') {
                        button.textContent = `Buy for $${card.cost}`;
                        button.disabled = state.money < card.cost || !!state.pendingSymbol;
                        button.addEventListener('click', () => attemptPurchase(choice));
                    } else if (choice.state === 'pending') {
                        button.textContent = 'Waiting for reel...';
                        button.disabled = true;
                    } else if (choice.state === 'placed') {
                        button.textContent = `Added to Reel ${choice.reel}`;
                        button.disabled = true;
                    } else {
                        button.textContent = 'Purchased';
                        button.disabled = true;
                    }

                    info.appendChild(button);
                    row.appendChild(preview);
                    row.appendChild(info);
                    elements.shopItems.appendChild(row);
                });
            }

            elements.reelPicker.hidden = !state.pendingSymbol;
            elements.shopContinue.disabled = !!state.pendingSymbol;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function openModal(modal) {
            if (!modal) return;
            modal.hidden = false;
            document.body.classList.add('modal-open');
        }

        function closeModal(modal) {
            if (!modal) return;
            modal.hidden = true;
            if (document.querySelectorAll('.modal:not([hidden])').length === 0) {
                document.body.classList.remove('modal-open');
            }
        }

        if (elements.machineSelect) {
            elements.machineSelect.addEventListener('change', (event) => {
                const machineId = event.target.value;
                if (!isMachineUnlocked(machineId)) {
                    updateMachineUI();
                    return;
                }
                if (machineId !== state.machine) {
                    state.machine = machineId;
                    saveSelectedMachine(machineId);
                    state.shopOpen = false;
                    closeModal(elements.shopModal);
                    closeModal(elements.endModal);
                    startGame();
                }
            });
        }

        elements.drawButton.addEventListener('click', drawHand);
        elements.playButton.addEventListener('click', playHand);
        elements.helpButton.addEventListener('click', () => openModal(elements.helpModal));
        elements.closeHelp.addEventListener('click', () => closeModal(elements.helpModal));
        elements.restartButton.addEventListener('click', restartGame);
        elements.shopContinue.addEventListener('click', finishShop);
        elements.skipShop.addEventListener('click', skipShop);
        elements.reelCancel.addEventListener('click', cancelPendingSymbol);
        elements.reelPickerButtons.forEach(button => button.addEventListener('click', (event) => {
            assignSymbolToReel(Number(event.currentTarget.dataset.reel));
        }));

        elements.shopModal.addEventListener('click', (event) => {
            if (event.target === elements.shopModal) {
                elements.shopIntro.textContent = 'Take your time! Choose wisely before the next blind.';
            }
        });

        elements.helpModal.addEventListener('click', (event) => {
            if (event.target === elements.helpModal) {
                closeModal(elements.helpModal);
            }
        });

        startGame();
    });
    </script>
</body>
</html>
